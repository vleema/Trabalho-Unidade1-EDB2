\section{Quick Sort}
\label{sec:quick-sort-teo}

Assim como o Merge Sort, o Quick Sort é um algoritmo baseado na técnica de divisão e conquista. A operação ocorre da seguinte forma:

\begin{enumerate}
	\item \textbf{Dividir}: O vetor \( A[p..r] \) é dividido em dois subvetores não vazios \( A[p..q] \) e \( A[q+1..r] \). O índice \( q \) é escolhido a partir do elemento localizado na metade do vetor original, denominado pivô. Os elementos do vetor são rearranjados de modo que os elementos à esquerda de \( q \) sejam menores ou iguais ao pivô, e os elementos à direita sejam maiores ou iguais ao pivô.

	\item \textbf{Conquistar}: Os dois subvetores \( A[p..q] \) e \( A[q+1..r] \) são ordenados através de chamadas recursivas ao Quick Sort.

	\item \textbf{Combinar}: Esta etapa não exige nenhum processamento adicional, pois, ao longo do processo recursivo, os elementos vão sendo ordenados no próprio vetor.
\end{enumerate}

\subsection{Quick Sort Iterativo}

\begin{algorithm}
	\caption{Iterative Quick Sort}
	\label{algo:iterative_quick_sort}
	\begin{algorithmic}[1]
		\Require{Lista $A$}
		\Ensure{Lista $A$ ordenada}
		\Statex

		\Function{particao}{$A, p, r$}
		\State declare $pivo, i, j$ como numérico
		\State $pivo \gets A[(p + r) / 2]$
		\State $i \gets p - 1$
		\State $j \gets r + 1$
		\While{$i < j$}
		\Repeat
		\State $j \gets j - 1$
		\Until{$A[j] \leq pivo$}
		\Repeat
		\State $i \gets i + 1$
		\Until{$A[i] \geq pivo$}
		\If{$i < j$}
		\State troca($A, i, j$)
		\EndIf
		\EndWhile
		\State \Return $j$
		\EndFunction
		\Statex

		\Function{IterativeQuickSort}{$A$}
		\If{$A$ estiver vazio}
		\State \Return
		\EndIf
		\State Crie uma pilha com o par $(0, \text{tamanho de } A - 1)$

		\While{a pilha não estiver vazia}
		\State Remova $(\text{low}, \text{high})$ do topo da pilha

		\If{$\text{low} < \text{high}$}
		\State $\text{pivot\_index} \gets$ \Call{Particao}{$A, \text{low}, \text{high}$}

		\If{$\text{pivot\_index} > 0$}
		\State Adicione $(\text{low}, \text{pivot\_index} - 1)$ na pilha \Comment{Lado esquerdo}
		\EndIf
		\State Adicione $(\text{pivot\_index} + 1, \text{high})$ na pilha \Comment{Lado direito}
		\EndIf
		\EndWhile
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\FloatBarrier


\subsection{Quick Sort Recursivo}

\begin{algorithm}
	\caption{Quick Sort}
	\label{algo:bubble_sort}
	\begin{algorithmic}[1]
		\Require{Lista $A = A_1, A_2, \ldots, A_n$}
		\Ensure{Lista $A$ ordenada}
		\Statex
		\Function{troca}{$A, i, j$}
		\State declare $aux$ como numérico
		\State $aux \gets A[i]$
		\State $A[i] \gets A[j]$
		\State $A[j] \gets aux$
		\EndFunction
		\Statex

		\Function{particao}{$A, p, r$}
		\State declare $pivo, i, j$ como numérico
		\State $pivo \gets A[(p + r) / 2]$
		\State $i \gets p - 1$
		\State $j \gets r + 1$
		\While{$i < j$}
		\Repeat
		\State $j \gets j - 1$
		\Until{$A[j] \leq pivo$}
		\Repeat
		\State $i \gets i + 1$
		\Until{$A[i] \geq pivo$}
		\If{$i < j$}
		\State troca($A, i, j$)
		\EndIf
		\EndWhile
		\State \Return $j$
		\EndFunction
		\Statex

		\Function{quickSort}{$A, p, r$}
		\State declare $q$ como numérico
		\If{$p < r$}
		\State $q \gets$ \Call{particao}{$A, p, r$}
		\State \Call{quickSort}{$A, p, q$}
		\State \Call{quickSort}{$A, q+1, r$}
		\EndIf
		\EndFunction

	\end{algorithmic}
\end{algorithm}
\FloatBarrier

\newpage

\subsubsection{Análise do Quick Sort Recursivo}
Primeiro, devemos definir a relação de recorrência do algoritmo.

No procedimento de partição, o tempo de execução é limitado pelo tamanho \( n \) do vetor. Isso ocorre porque ele compara todos os elementos do vetor com o pivô enquanto os índices atenderem a condição \( i < j \). Logo, o procedimento de partição realizará \( O(n) \) comparações.

Os dois vetores gerados pelo procedimento de partição são resolvidos recursivamente. O tamanho desses vetores depende do valor do pivô escolhido na função de partição. Suponha que \( k \) elementos estejam ao lado esquerdo do pivô e \( (n - k - 1) \) elementos estejam à direita do pivô após a partição.

Logo, a complexidade do passo recursivo será a soma das recorrências da ordenação dos dois vetores: \( T(k) + T(n - k - 1) \).

Somando a parte recursiva do algoritmo com o procedimento de partição, teremos:
\[
	T(n) = O(n) + T(k) + T(n - k - 1)
\]

O tempo de execução do Quick Sort depende se o particionamento é ou não balanceado. Se for balanceado, o algoritmo executa tão rapidamente quanto o Merge Sort; caso contrário, ele executará tão lentamente quanto o Insertion Sort. Assim, temos dois casos:

\begin{itemize}
	\item \textbf{Pior caso:} Ocorre quando o pivô é o maior ou o menor elemento do vetor. Aqui, um vetor terá \( n-1 \) elementos e o outro vetor será vazio (não se esqueça do pivô).

	      Para calcular a complexidade do Quick Sort no pior caso, substituímos \( k = n - 1 \) na recorrência encontrada:
	      \[
		      T(n) = O(n) + T(n-1) + T(n - n + 1 - 1)
	      \]
	      \[
		      = cn + T(n-1) \quad \text{(considere \( c \) uma constante)}
	      \]

	      Observe que, neste caso, o algoritmo se comportará da mesma forma que o BubbleSort, que já foi analisado neste trabalho.

	\item \textbf{Melhor caso:} Ocorre quando o pivô é o elemento médio do vetor a ser ordenado em cada chamada do algoritmo de partição. Nessa situação, o processo de partição será balanceado e o tamanho de cada vetor gerado pela partição será, aproximadamente, \( n/2 \).

	      Para calcular a complexidade do Quick Sort nesse caso, substituímos \( k = n/2 \) na recorrência encontrada:
	      \[
		      T(n) = O(n) + T(n/2) + T(n - n/2 - 1)
	      \]
	      \[
		      \approx cn + 2T(n/2)
	      \]

	      Agora, note que o Quick Sort, em seu melhor caso, se comportal da mesma forma do Merge Sort, o qual já foi analisado neste trabalho.

\end{itemize}

