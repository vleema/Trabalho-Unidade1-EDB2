\section{Quick Sort}
\label{sec:quick-sort-teo}

Assim como o Merge Sort, o Quick Sort é um algoritmo baseado na técnica de divisão e conquista. A operação ocorre da seguinte forma:

\begin{enumerate}
	\item \textbf{Dividir}: O vetor \( A[p..r] \) é dividido em dois subvetores não vazios \( A[p..q] \) e \( A[q+1..r] \). O índice \( q \) é escolhido a partir do elemento localizado na metade do vetor original, denominado pivô. Os elementos do vetor são rearranjados de modo que os elementos à esquerda de \( q \) sejam menores ou iguais ao pivô, e os elementos à direita sejam maiores ou iguais ao pivô.

	\item \textbf{Conquistar}: Os dois subvetores \( A[p..q] \) e \( A[q+1..r] \) são ordenados através de chamadas recursivas ao Quick Sort.

	\item \textbf{Combinar}: Esta etapa não exige nenhum processamento adicional, pois, ao longo do processo recursivo, os elementos vão sendo ordenados no próprio vetor.
\end{enumerate}

\subsection{Quick Sort Recursivo}

\begin{algorithm}
	\caption{Quick Sort}
	\label{algo:bubble_sort}
	\begin{algorithmic}[1]
		\Require{Lista $A = A_1, A_2, \ldots, A_n$}
		\Ensure{Lista $A$ ordenada}
		\Statex
		\Function{troca}{$A, i, j$}
		\State declare $aux$ como numérico
		\State $aux \gets A[i]$
		\State $A[i] \gets A[j]$
		\State $A[j] \gets aux$
		\EndFunction
		\Statex
		\Function{quickSort}{$A, p, r$}
		\State declare $q$ como numérico
		\If{$p < r$}
		\State $q \gets$ \Call{particao}{$A, p, r$}
		\State \Call{quickSort}{$A, p, q$}
		\State \Call{quickSort}{$A, q+1, r$}
		\EndIf
		\EndFunction

	\end{algorithmic}
\end{algorithm}
\FloatBarrier

\newpage
\subsection{Quick Sort Iterativo}

\begin{algorithm}
	\caption{Quick Sort iterativo}
	\label{algo:iterative_quick_sort}
	\begin{algorithmic}[1]
		\Require{Lista $A$}
		\Ensure{Lista $A$ ordenada}
		\Statex

		\Function{QuickSortIterativo}{$A$}
		\If{$A$ estiver vazio}
		\State \Return
		\EndIf
		\State Crie uma pilha com o par $(0, \text{tamanho de } A - 1)$

		\While{a pilha não estiver vazia}
		\State Remova $(\text{limiteEsquerdo}, \text{limiteDireito})$ do topo da pilha

		\If{$\text{limiteEsquerdo} < \text{limiteDireito}$}
		\State $\text{pivotIndex} \gets$ \Call{Particao}{$A, \text{limiteEsquerdo}, \text{limiteDireito}$}

		\If{$\text{pivotIndex} > 0$}
		\State Adicione $(\text{limiteEsquerdo}, \text{pivotIndex} - 1)$ na pilha \Comment{Lado esquerdo}
		\EndIf
		\State Adicione $(\text{pivotIndex} + 1, \text{limiteDireito})$ na pilha \Comment{Lado direito}
		\EndIf
		\EndWhile
		\EndFunction
	\end{algorithmic}
\end{algorithm}
\FloatBarrier

\newpage
\subsection{Função auxiliar Partição}

\begin{algorithm}
	\caption{Partição}
	\label{algo:particao}
	\begin{algorithmic}[1]
		\Require{A = $a_1, a_2, a_3, \ldots, a_n$, limiteEsquerdo, limiteDireito}
		\Ensure{O índice do pivô}
		\Function{particao}{$A, \text{limiteEsquerdo}, \text{limiteDireito}$}
		\State declare $pivot, i, j$ como numérico
		\State $pivot \gets A[(\text{limiteEsquerdo} + r) / 2]$
		\State $i \gets \text{limiteEsquerdo}- 1$
		\State $j \gets \text{limiteDireito} + 1$
		\While{$i < j$}
		\Repeat
		\State $j \gets j - 1$
		\Until{$A[j] \leq pivot$}
		\Repeat
		\State $i \gets i + 1$
		\Until{$A[i] \geq pivot$}
		\If{$i < j$}
		\State troca($A, i, j$)
		\EndIf
		\EndWhile
		\State \Return $j$
		\EndFunction
		\Statex
	\end{algorithmic}
\end{algorithm}
\FloatBarrier

\subsection{Análise de Complexidade}

\subsubsection{Análise da versão recursiva}

Primeiro, devemos definir a relação de recorrência do algoritmo.

No procedimento de partição, o tempo de execução é limitado pelo tamanho \( n \) do vetor. Isso ocorre porque ele compara todos os elementos do vetor com o pivô enquanto os índices atenderem a condição \( i < j \). Logo, o procedimento de partição realizará \( O(n) \) comparações.

Os dois vetores gerados pelo procedimento de partição são resolvidos recursivamente. O tamanho desses vetores depende do valor do pivô escolhido na função de partição. Suponha que \( k \) elementos estejam ao lado esquerdo do pivô e \( (n - k - 1) \) elementos estejam à direita do pivô após a partição.

Logo, a complexidade do passo recursivo será a soma das recorrências da ordenação dos dois vetores: \( T(k) + T(n - k - 1) \).

Somando a parte recursiva do algoritmo com o procedimento de partição, teremos:
\[
	T(n) = O(n) + T(k) + T(n - k - 1)
\]

O tempo de execução do Quick Sort depende se o particionamento é ou não balanceado. Se for balanceado, o algoritmo executa tão rapidamente quanto o Merge Sort; caso contrário, ele executará tão lentamente quanto o Insertion Sort. Assim, temos dois casos:

\begin{itemize}
	\item \textbf{Pior caso:} Ocorre quando o pivô é o maior ou o menor elemento do vetor. Aqui, um vetor terá \( n-1 \) elementos e o outro vetor será vazio (não se esqueça do pivô).

	      Para calcular a complexidade do Quick Sort no pior caso, substituímos \( k = n - 1 \) na recorrência encontrada:
	      \[
		      T(n) = O(n) + T(n-1) + T(n - n + 1 - 1)
	      \]
	      \[
		      = cn + T(n-1) \quad \text{(considere \( c \) uma constante)}
	      \]

	      Observe que, neste caso, o algoritmo se comportará da mesma forma que o BubbleSort, que já foi analisado neste trabalho.

	\item \textbf{Melhor caso:} Ocorre quando o pivô é o elemento médio do vetor a ser ordenado em cada chamada do algoritmo de partição. Nessa situação, o processo de partição será balanceado e o tamanho de cada vetor gerado pela partição será, aproximadamente, \( n/2 \).

	      Para calcular a complexidade do Quick Sort nesse caso, substituímos \( k = n/2 \) na recorrência encontrada:
	      \[
		      T(n) = O(n) + T(n/2) + T(n - n/2 - 1)
	      \]
	      \[
		      \approx cn + 2T(n/2)
	      \]

	      Agora, note que o Quick Sort, em seu melhor caso, se comportal da mesma forma do Merge Sort, o qual já foi analisado neste trabalho.

\end{itemize}

\subsubsection{Análise da versão iterativa}

Para determinar a complexidade da versão iterativa, precisamos estimar o tamanho da estrutura de dados "pilha" que simula as chamadas recursivas da outra versão. De forma que seja compreendido quando o loop "while" vai parar. Para tal, teremos dois casos:

\begin{itemize}
	\item \textbf{Melhor caso}: Vamos supor que a função "partição" sempre particiona a lista em duas sublistas iguais, ou seja, o pivô escolhido é sempre a média da lista maior, de forma que:
	      \begin{adjustwidth}{-1.8em}{}
		      \begin{tikzcd}[sep=small]
			      &&&& n &&&&& cn \\
			      \\
			      &&& {n/2} && {n/2} &&&& {2 \cdot cn/2 =cn} \\
			      \\
			      & {n/4} && {n/4} && {n/4} && {n/4} && {4 \cdot cn/4 = cn} \\
			      \\
			      {n/8} & {n/8} & {n/8} & {n/8} && {n/8} & {n/8} & {n/8} & {n/8} & {8 \cdot cn/8 = cn} \\
			      \vdots & \vdots & \vdots & \vdots && \vdots & \vdots & \vdots & \vdots \\
			      1 & 1 & 1 & 1 && 1 & 1 & 1 & 1 & {n \cdot c = cn}
			      \arrow[from=1-5, to=3-4]
			      \arrow[from=1-5, to=3-6]
			      \arrow[from=3-4, to=5-2]
			      \arrow[from=3-4, to=5-4]
			      \arrow[from=3-6, to=5-6]
			      \arrow[from=3-6, to=5-8]
			      \arrow[from=5-2, to=7-1]
			      \arrow[from=5-2, to=7-2]
			      \arrow[from=5-4, to=7-3]
			      \arrow[from=5-4, to=7-4]
			      \arrow[from=5-6, to=7-6]
			      \arrow[from=5-6, to=7-7]
			      \arrow[from=5-8, to=7-8]
			      \arrow[from=5-8, to=7-9]
		      \end{tikzcd}
	      \end{adjustwidth}
\end{itemize}

